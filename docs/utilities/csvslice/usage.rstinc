

Usage overview and examples
===========================


These examples refer to data as found in :download:`ids.csv </../examples/ids.csv>`


Get the first n rows with --head
--------------------------------

Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolor


Get the last n rows with --tail
-------------------------------

Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.


Slicing individual rows with --index
------------------------------------

You can specify rows to be sliced by 0-based index:


.. code-block:: sh

    csvslice -i 1 ids.csv
    id,val
    1,b



You can also specify a series of individual indexes as a comma-delimited string:


.. code-block:: sh

    csvslice -i 0,5 ids.csv
    id,val
    0,a
    5,f




Slicing rows by an index range
------------------------------

Rows can be specified by using a range syntax: ``start-end``

The range is *inclusive*:


.. code-block:: sh

    $ csvslice -i 1-3 ids.csv
    id,val
    1,b
    2,c
    3,d


Omitting the right-side *end* value returns an open range of values:

.. code-block:: sh

    $ csvslice -i 3- ids.csv
    id,val
    3,d
    4,e
    5,f



Like indexes, a series of ranges can be specified as a comma-delimited string:


.. code-block:: sh

    $ csvslice -i 0-1,3- ids.csv
    id,val
    0,a
    1,b
    3,d
    4,e
    5,f



And you can combine ranges with individual indexes:

.. code-block:: sh

    $ csvslice -i 0,2-3,5 ids.csv
    id,val
    0,a
    2,c
    3,d
    5,f



Errors and quirks
-----------------


Even though ``3-1`` and is technically a valid range,  :command:`csvslice` will throw an error if the ``end`` value is smaller than the ``start`` value:

.. code-block:: sh

    $ csvslice -i 3-1 examples/ids.csv
    InvalidRange: Invalid range specified: 3-1


For the most part, though, :command:`csvslice` isn't too whiny (in terms of warning you) about messy or otherwise nonsensical values for ``-i/--indexes``.

No matter what order you specify the indexes and ranges, it will always return rows in sequential order:

.. code-block:: sh

    $ csvslice -i 4,0,2 ids.csv
    id,val
    0,a
    2,c
    4,e


.. code-block:: sh

    $ csvslice -i 4,0-2,3 ids.csv
    id,val
    0,a
    1,b
    2,c
    3,d
    4,e


If you pass in repeated indexes and/or overlapping ranges, :command:`csvslice` will still only return the original, sequential data, i.e. it will *not* return duplicates of rows:

.. code-block:: sh

    $ csvslice -i 3,1,3,1,1 ids.csv
    id,val
    1,b
    3,d


.. code-block:: sh

    $ csvslice -i 1,0-2,1-3 ids.csv
    id,val
    0,a
    1,b
    2,c
    3,d



If you pass in references to non-existent row indexes, such as out-of-bounds numbers â€” those too are ignored:


.. code-block:: sh

    csvslice -i 5,42 ids.csv
    id,val
    5,f
